#!/bin/bash
PCM(){ PROMPT ;clear; PMENU;}
PROMPT()
{ printf "${CE}\e[18;$(( ($(tput cols)-46 )/2+1))f<< PRESSIONE QUALQUER TECLA  PARA CONTINUAR >>${FC}";
read -e -n1 PRMPT ;
local PRMPT ;
}
PMENU() 
{
#GERACOR;
COLS;
}
MENU() {
	tput clear
	printf "${CE}\e[2;${POS2}f----------------------------------------"
	printf "\e[3;${POS1}f------------------ MENU ------------------"
	printf "\e[4;${POS}f---\e[4;${POS3}f---"
	printf "\e[5;${POS}f---${CSM}    [1] Cadastrar       [2] Listar    ${CE}---"
	printf "\e[6;${POS}f---${CSM}    [3] Remover         [4] Alterar   ${CE}---"
	printf "\e[7;${POS}f---${CSM}    [5] Opção 5         [6] Opção 6   ${CE}---"
	printf "\e[8;${POS}f---${CSM}    [7] Cor Menu        [8] Exit      ${CE}---"
	printf "\e[9;${POS}f---\e[9;${POS3}f---"
	printf "${CE}\e[10;${POS1}f------------------------------------------"
	printf "\e[11;${POS2}f----------------------------------------\n\n"$FC""
	read -p " OPÇãO: " -n1 OPC
	case "$OPC" in
	1) FUNCAO_01 ;;
	2) FUNCAO_02 ;;
	3) FUNCAO_03 ;;
	4) FUNCAO_04 ;;
	5) echo -e "\n Criar FUNÇãO_05\n"; PCM ;;
	6) echo -e "\n Criar FUNÇãO_06\n"; PCM ;;
	7) echo -e "\n${CE} Centraliza e altera a cor do MENU${FC}"; sleep 1 ; PMENU ;;
	8) echo -e "\n\n Saindo...\n";sleep 0.5; exit ;;
	*) MSGM ; PMENU ;;
	esac
}
COLS() {
	COLS=$(tput cols)
	POS=$(((COLS-44)/2+1))
	POS1=$((POS+1))
	POS2=$((POS+2))
	POS3=$((POS2+39))
	(($COLS>=44)) && MENU || { echo -e "$CVA AJUSTE A TELA!\n No MÍNIMO 44 Colunas $FC" ; PCM ; }
}
GERACOR() {
	local cnt=$((1+RANDOM%31));local atb=$((RANDOM%2));
	CSM="\e["$atb";38;5;"$cnt"m"
}
MSGM() { echo -e "$CVA\n\n \" OPÇãO INVáLIDA! \" $FC" ; sleep 1.25 ; }
PMENU
bold() { echo -e "\e[1m$@\e[0m" ; }
red() { echo -e "\e[31m$@\e[0m" ; }
green() { echo -e "\e[32m$@\e[0m" ; }
yellow() { echo -e "\e[33m$@\e[0m" ; }
die() { red "ERR: $@" >&2 ; exit 2 ; }
silent() { "$@" > /dev/null 2>&1 ; }
output() { echo -e "- $@" ; }
outputn() { echo -en "- $@ ... " ; }
ok() { green "${@:-OK}" ; }
pushd() { command pushd "$@" >/dev/null ; }
popd() { command popd "$@" >/dev/null ; }
function set_wget ()
{
    if [ -f /etc/fedora-release ]
    then
        WGET="wget --quiet --show-progress"
    else
        WGET="wget"
    fi
}
function check_vmname_set ()
{
    [ -n "${VMNAME}" ] || die "VMNAME not set."
}
function delete_vm ()
{
    check_vmname_set
    if [ "${DOMAIN_EXISTS}" -eq 1 ]
    then
        outputn "Destroying ${VMNAME} domain"
        virsh destroy --graceful ${VMNAME} > /dev/null 2>&1 \
            && ok \
            || yellow "(Domain is not running.)"
        outputn "Undefining ${VMNAME} domain"
        virsh undefine --managed-save ${VMNAME} > /dev/null 2>&1 \
            && ok \
            || die "Could not undefine domain."
    else
        output "Domain ${VMNAME} does not exist"
    fi
    [[ -d ${VMDIR}/${VMNAME} ]] && DISKDIR=${VMDIR}/${VMNAME} || DISKDIR=${IMAGEDIR}/${VMNAME}
    [ -d $DISKDIR ] \
        && outputn "Deleting ${VMNAME} files" \
        && rm -rf $DISKDIR \
        && ok
    if [ "${STORPOOL_EXISTS}" -eq 1 ]
    then
        outputn "Destroying ${VMNAME} storage pool"
        virsh pool-destroy ${VMNAME} > /dev/null 2>&1 && ok
    else
        output "Storage pool ${VMNAME} does not exist"
    fi
}
function check_ssh_key ()
{
    local key
	if [ -z "${PUBKEY}" ]; then
	for key in ~/.ssh/id_{rsa,dsa,ed25519}.pub; do
            if [ -f "$key" ]; then
                PUBKEY="$key"
                break
            fi
        done
    fi
    if [ ! -f "${PUBKEY}" ]
    then
	   die "Please generate an SSH keypair using 'ssh-keygen -t rsa' or \
             specify one with the "-k" flag."
    else
	  KEY=$(<${PUBKEY})
    fi
}
function domain_exists ()
{
    virsh dominfo "${1}" > /dev/null 2>&1 \
        && DOMAIN_EXISTS=1 \
        || DOMAIN_EXISTS=0
}
function storpool_exists ()
{
    virsh pool-info "${1}" > /dev/null 2>&1 \
        && STORPOOL_EXISTS=1 \
        || STORPOOL_EXISTS=0
}
function check_delete_known_host ()
{
    output "Checking for ${IP} in known_hosts file"
    grep -q ${IP} ${HOME}/.ssh/known_hosts \
        && outputn "Found entry for ${IP}. Removing" \
        && (sed --in-place "/^${IP}/d" ~/.ssh/known_hosts && ok ) \
        || output "No entries found for ${IP}"
}
function create_vm ()
{
	mkdir -p ${VMDIR}
	check_vmname_set
	 [ -d "${VMDIR}/${VMNAME}" ] && rm -rf ${VMDIR}/${VMNAME}
    mkdir -p ${VMDIR}/${VMNAME}
    pushd ${VMDIR}/${VMNAME}
touch ${VMNAME}.log
 cat > $USER_DATA << _EOF_
 Content-Type: multipart/mixed; boundary="==BOUNDARY=="
MIME-Version: 1.0
--==BOUNDARY==
Content-Type: text/cloud-config; charset="us-ascii"
#cloud-config
# Hostname management
preserve_hostname: False
hostname: ${VMNAME}
fqdn: ${VMNAME}.${DNSDOMAIN}
# Users
users:
    - default
    - name: ${ADDITIONAL_USER}
      groups: ['${SUDOGROUP}']
      shell: /bin/bash
      sudo: ALL=(ALL) NOPASSWD:ALL
      ssh-authorized-keys:
        - ${KEY}
# Configure where output will go
output:
  all: ">> /var/log/cloud-init.log"
# configure interaction with ssh server
ssh_genkeytypes: ['ed25519', 'rsa']
# Install my public ssh key to the first user-defined user configured
# in cloud.cfg in the template (which is centos for CentOS cloud images)
ssh_authorized_keys:
  - ${KEY}
timezone: ${TIMEZONE}
# Remove cloud-init when finished with it
runcmd:
  - ${NETRESTART}
  - ${CLOUDINITDISABLE}
_EOF_
    if [ ! -z "${SCRIPTNAME+x}" ]
    then
        SCRIPT=$(< $SCRIPTNAME)
        cat >> $USER_DATA << _EOF_
--==BOUNDARY==
Content-Type: text/x-shellscript; charset="us-ascii"
${SCRIPT}
--==BOUNDARY==--
_EOF_
    else
       cat >> $USER_DATA << _EOF_
--==BOUNDARY==--
_EOF_
    fi
    { echo "instance-id: ${VMNAME}"; echo "local-hostname: ${VMNAME}"; } > $META_DATA
    outputn "Copying cloud image ($(basename ${IMAGE}))"
    DISK=${VMNAME}.qcow2
    cp $IMAGE $DISK && ok
    if $RESIZE_DISK
    then
        outputn "Resizing the disk to $DISK_SIZE"
        qemu-img create -f qcow2 \
            -o preallocation=metadata $DISK.new $DISK_SIZE &>> ${VMNAME}.log \
            && virt-resize --quiet --expand /dev/sda1 $DISK $DISK.new &>> ${VMNAME}.log \
            && (mv $DISK.new $DISK && ok) \
            || die "Could not resize disk."
    fi
	 outputn "Generating ISO for cloud-init"
    if [ `which genisoimage &>/dev/null` ]
    then
        genisoimage -output $CI_ISO \
            -volid cidata \
            -joliet -r $USER_DATA $META_DATA &>> ${VMNAME}.log \
            && ok \
            || die "Could not generate ISO."
    else
        mkisofs -o $CI_ISO -V cidata -J -r $USER_DATA $META_DATA &>> ${VMNAME}.log \
            && ok \
            || die "Could not generate ISO."
    fi
    if [ "${VERBOSE}" -eq 1 ]
    then
        output "Creating storage pool with the following command"
        printf "    virsh pool-create-as \\ \n"
        printf "      --name ${VMNAME} \\ \n"
        printf "      --type dir \\ \n"
        printf "      --target ${VMDIR}/${VMNAME} \n"
    else
        outputn "Creating storage pool"
    fi
	(virsh pool-create-as \
        --name ${VMNAME} \
        --type dir \
        --target ${VMDIR}/${VMNAME} &>> ${VMNAME}.log && ok) \
		 || die "Could not create storage pool."
        if [ -z "${MACADDRESS}" ]
    then
        NETWORK_PARAMS="bridge=${BRIDGE},model=virtio"
    else
        NETWORK_PARAMS="bridge=${BRIDGE},model=virtio,mac=${MACADDRESS}"
    fi
    if [ "${VERBOSE}" -eq 1 ]
    then
        output "Installing the domain with the following command"
        printf "    virt-install \\ \n"
        printf "      --import \\ \n"
        printf "      --name ${VMNAME} \\ \n"
        printf "      --memory ${MEMORY} \\ \n"
        printf "      --vcpus ${CPUS} \\ \n"
        printf "      --cpu ${FEATURE} \\ \n"
        printf "      --disk ${DISK},format=qcow2,bus=virtio \\ \n"
        printf "      --disk ${CI_ISO},device=cdrom \\ \n"
        printf "      --network ${NETWORK_PARAMS} \\ \n"
        printf "      --os-type=linux \\ \n"
        printf "      --os-variant=${OS_VARIANT} \\ \n"
        printf "      --graphics ${GRAPHICS},port=${PORT},listen=localhost \\ \n"
        printf "      --noautoconsole  \n"
    else
        outputn "Installing the domain"
    fi 
	(virt-install --import \
    --name ${VMNAME} \
    --memory ${MEMORY} \
    --vcpus ${CPUS} \
    --cpu ${FEATURE} \
    --disk ${DISK},format=qcow2,bus=virtio \
     --disk ${CI_ISO},device=cdrom \
     --network ${NETWORK_PARAMS} \
     --os-type=linux \
     --os-variant=${OS_VARIANT} \
     --graphics ${GRAPHICS},port=${PORT},listen=localhost \
     --noautoconsole &>> ${VMNAME}.log && ok ) \
    virsh dominfo ${VMNAME} &>> ${VMNAME}.log
	   || die "Could not create domain with virt-install."
	}
	 if $AUTOSTART
    then
    outputn "Enabling autostart"
     virsh autostart \
    --domain ${VMNAME} > /dev/null 2>&1 \
     && ok \
	|| die "Could not enable autostart."   
    fi
	virsh change-media ${VMNAME} hda --eject --config &>> ${VMNAME}.log
	outputn "Cleaning up cloud-init files"
    rm $USER_DATA $META_DATA $CI_ISO && ok

    if [ -f "/var/lib/libvirt/dnsmasq/${BRIDGE}.status" ]
    then
        outputn "Waiting for domain to get an IP address"
        MAC=$(virsh dumpxml ${VMNAME} | awk -F\' '/mac address/ {print $2}')
        while true
        do
            IP=$(grep -B1 $MAC /var/lib/libvirt/dnsmasq/$BRIDGE.status | head \
                 -n 1 | awk '{print $2}' | sed -e s/\"//g -e s/,//)
            if [ "$IP" = "" ]
            then
                sleep 1
            else
                ok
                break
            fi
        done
        printf "\n"
        check_delete_known_host
    else
        outputn "Bridge looks like a layer 2 bridge, get the domain's IP address from your DHCP server"
        IP="<IP address>"
    fi
    printf "\n"
    output "SSH to ${VMNAME}: 'ssh ${LOGIN_USER}@${IP}' or 'ssh ${LOGIN_USER}@${VMNAME}'"
    CONSOLE=$(virsh domdisplay ${VMNAME})
	 if [ "${GRAPHICS}" = 'vnc' ]
    then
        CONSOLE_NO_PORT=$(echo $CONSOLE | cut -d ':' -f 1,2 -)
        CONSOLE_PORT=$(expr 5900 + $(echo $CONSOLE | cut -d ':' -f 3 -))
        output "Console at ${CONSOLE_NO_PORT}:${CONSOLE_PORT}"
    else
        output "Console at ${CONSOLE}"
    fi
    output "DONE"
    popd
}
function set_defaults ()
{
CPUS=1                          # Number of virtual CPUs
    FEATURE=host                    # Use host cpu features to the guest
    MEMORY=1024                     # Amount of RAM in MB
    DISK_SIZE=""                    # Disk Size in GB
    DNSDOMAIN=example.local         # DNS domain
    GRAPHICS=spice                  # Graphics type
    RESIZE_DISK=false               # Resize disk (boolean)
    IMAGEDIR=${HOME}/virt/images    # Directory to store images
    VMDIR=${HOME}/virt/vms    # Directory to store images
    BRIDGE=virbr0                   # Hypervisor bridge
    PUBKEY=""                       # SSH public key
    DISTRO=centos7                  # Distribution
    MACADDRESS=""                   # MAC Address
    PORT=-1                         # Console port
    TIMEZONE=US/Eastern             # Timezone
    ADDITIONAL_USER=${USER}         # User
    VERBOSE=0                       # Verbosity
    # Reset OPTIND
    OPTIND=1
}
function set_custom_defaults ()
{
	 if [ -f ~/.kivrc ];
    then
        source ${HOME}/.kivrc
    fi
}
function create ()
{
	while getopts ":a:b:c:d:D:f:g:i:k:l:m:M:p:s:t:T:u:hv" opt
    do
        case "$opt" in
            a ) AUTOSTART=true ;;
            b ) BRIDGE="${OPTARG}" ;;
            c ) CPUS="${OPTARG}" ;;
            d ) DISK_SIZE="${OPTARG}" ;;
            D ) DNSDOMAIN="${OPTARG}" ;;
            f ) FEATURE="${OPTARG}" ;;
            g ) GRAPHICS="${OPTARG}" ;;
            i ) IMAGE="${OPTARG}" ;;
            k ) PUBKEY="${OPTARG}" ;;
            l ) IMAGEDIR="${OPTARG}" ;;
            L ) VMDIR="${OPTARG}" ;;
            m ) MEMORY="${OPTARG}" ;;
            M ) MACADDRESS="${OPTARG}" ;;
            p ) PORT="${OPTARG}" ;;
            s ) SCRIPTNAME="${OPTARG}" ;;
            t ) DISTRO="${OPTARG}" ;;
            T ) TIMEZONE="${OPTARG}" ;;
            u ) ADDITIONAL_USER="${OPTARG}" ;;
            v ) VERBOSE=1 ;;
            h ) usage ;;
			 * )  die "Unsupported option. Run 'kvm-install-vm help create'." ;;
			  esac
    done
    shift $((OPTIND - 1))
	if [ -n "${DISK_SIZE}" ]
    then
        RESIZE_DISK=true
        DISK_SIZE="${DISK_SIZE}G"   
    fi
if [ "$#" != 1 ]
    then
        printf "Please specify a single host to create.\n"
        printf "Run 'kvm-install-vm help create' for usage.\n"
        exit 1
    else
        VMNAME=$1
    fi
USER_DATA=user-data
    META_DATA=meta-data
    CI_ISO=${VMNAME}-cidata.iso
check_ssh_key
    if [ ! -z "${IMAGE+x}" ]
    then
        output "Using custom QCOW2 image: ${IMAGE}."
        OS_VARIANT="auto"
        LOGIN_USER="<use the default account in your custom image>"
    else
        fetch_images
    fi
	 domain_exists "${VMNAME}"
    if [ "${DOMAIN_EXISTS}" -eq 1 ]; then
        echo -n "[WARNING] ${VMNAME} already exists.  "
        read -p "Do you want to overwrite ${VMNAME} [y/N]? " -r
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            remove ${VMNAME}
        else
            echo -e "\nNot overwriting ${VMNAME}. Exiting..."
            exit 1
        fi
    fi
 set_network_restart_cmd
 set_cloud_init_remove
 set_sudo_group
 create_vm
}
function attach-disk ()
{
FORMAT=qcow2
while getopts ":d:f:ps:t:h" opt
    do
        case "$opt" in
            d ) DISKSIZE="${OPTARG}G" ;;
            f ) FORMAT="${OPTARG}" ;;
            p ) PERSISTENT="${OPTARG}" ;;
            s ) SOURCE="${OPTARG}" ;;
            t ) TARGET="${OPTARG}" ;;
            h ) usage ;;
            * ) die "Unsupported option. Run 'kvm-install-vm help attach-disk'." ;;
		 esac
    done	
	shift $((OPTIND - 1))

    [ ! -z ${TARGET} ] || die "You must specify a target device, for e.g. '-t vdb'"
    [ ! -z ${DISKSIZE} ]  die "You must specify a size (in GB) for the new device, for e.g. '-d 5'"
	if [ "$#" != 1 ]
    then
        printf "Please specify a single host to attach a disk to.\n"
        printf "Run 'kvm-install-vm help attach-disk' for usage.\n"
        exit 1
    else
    VMNAME=$1
	[[ -d ${VMDIR}/${VMNAME} ]] && DISKDIR=${VMDIR}/${VMNAME} || DISKDIR=${IMAGEDIR}/${VMNAME}
        DISKNAME=${VMNAME}-${TARGET}-${DISKSIZE}.${FORMAT}
        if [ ! -f "${DISKDIR}/${DISKNAME}" ]
        then
            outputn "Creating new '${TARGET}' disk image for domain ${VMNAME}"
            (qemu-img create -f ${FORMAT} -o size=$DISKSIZE,preallocation=metadata \
                ${DISKDIR}/${DISKNAME} &>> ${DISKDIR}/${VMNAME}.log  && ok ) && \

            outputn "Attaching ${DISKNAME} to domain ${VMNAME}"
            (virsh attach-disk ${VMNAME} \
                --source $DISKDIR/${DISKNAME} \
                --target ${TARGET} \
                --subdriver ${FORMAT} \
                --cache none \
                --persistent &>> ${DISKDIR}/${VMNAME}.log && ok ) \
                || die "Could not attach disk."
        else
            die "Target ${TARGET} is already created or in use."
        fi
    fi
}
subcommand="${1:-none}"
[[ "${subcommand}" != "none" ]] && shift
case "${subcommand}" in
    none)
        usage
        ;;
    help)
        if [[ "${1:-none}" == "none" ]]; then
            usage
        elif [[ "$1" =~ ^create$|^remove$|^list$|^attach-disk$ ]]; then
            usage_subcommand "$1"
        else
            printf "'$1' is not a valid subcommand.\n\n"
            usage
        fi
        ;;
    list)
        virsh list --all
        exit 0
        ;;
    create|remove|attach-disk|remove-disk)
        if [[ "${1:-none}" == "none" ]]; then
            usage_subcommand "${subcommand}"
        elif [[ "$1" =~ ^help$ ]]; then
            usage_subcommand "${subcommand}"
        else
            set_defaults
            set_custom_defaults
            "${subcommand}" "$@"
            exit $?
        fi
        ;;
    *) die "'${subcommand}' is not a valid subcommand.  See 'kvm-install-vm help' for a list of subcommands."
        ;;
esac
PMENU
